import { Request, Response } from "express";
import { supabaseAdmin } from "../lib/supabase";
import axios from "axios";

/**
 * GET /api/cron/periodic-risk-review
 */
export async function periodicRiskReview(req: Request, res: Response) {
  try {
    // ðŸ” Verify cron secret
    const authHeader = req.headers.authorization;
    if (
      process.env.CRON_SECRET &&
      authHeader !== `Bearer ${process.env.CRON_SECRET}`
    ) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const now = new Date().toISOString();

    // âœ… Use service-role Supabase
    const { data: assessmentsDue, error } = await supabaseAdmin
      .from("automated_risk_assessments")
      .select(
        "id, ai_system_id, next_review_date, review_frequency_months, monitoring_enabled"
      )
      .eq("monitoring_enabled", true)
      .lte("next_review_date", now);

    if (error) {
      console.error("Query error:", error);
      return res.status(500).json({ error: "Database query failed" });
    }

    if (!assessmentsDue || assessmentsDue.length === 0) {
      return res.status(200).json({
        message: "No assessments due for periodic review",
        count: 0,
      });
    }

    const baseUrl =
      process.env.INTERNAL_API_BASE_URL || "http://localhost:3001";

    const results = [];

    for (const assessment of assessmentsDue) {
      try {
        const response = await axios.post(
          `${baseUrl}/api/ai-systems/${assessment.ai_system_id}/automated-risk-assessment`,
          {
            trigger_type: "periodic_review",
            previous_assessment_id: assessment.id,
          },
          {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${process.env.INTERNAL_SERVICE_TOKEN}`,
            },
          }
        );

        results.push({
          system_id: assessment.ai_system_id,
          assessment_id: response.data.id,
          status: "success",
        });
      } catch (err: any) {
        results.push({
          system_id: assessment.ai_system_id,
          status: "error",
          error: err.message,
        });
      }
    }

    return res.status(200).json({
      total: assessmentsDue.length,
      success: results.filter(r => r.status === "success").length,
      errors: results.filter(r => r.status === "error").length,
      results,
    });
  } catch (err: any) {
    console.error("Periodic risk review error:", err);
    return res.status(500).json({ error: err.message });
  }
}

/**
 * POST /api/cron/regenerate-documentation
 */
export async function regenerateDocumentation(req: Request, res: Response) {
  try {
    const cronSecret = req.headers["x-cron-secret"];
    if (process.env.CRON_SECRET && cronSecret !== process.env.CRON_SECRET) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const { data: outdatedDocs, error } = await supabaseAdmin
      .from("compliance_documentation")
      .select("ai_system_id, regulation_type")
      .eq("status", "outdated");

    if (error) {
      console.error(error);
      return res.status(500).json({ error: "Failed to fetch docs" });
    }

    if (!outdatedDocs || outdatedDocs.length === 0) {
      return res.json({ regenerated: 0 });
    }

    const grouped = new Map<string, string[]>();

    for (const doc of outdatedDocs) {
      if (!grouped.has(doc.ai_system_id)) {
        grouped.set(doc.ai_system_id, []);
      }
      grouped.get(doc.ai_system_id)!.push(doc.regulation_type);
    }

    let success = 0;
    let failure = 0;

    for (const [systemId, regulations] of grouped.entries()) {
      try {
        const {
          autoGenerateDocumentationIfNeeded,
        } = await import(
          "../../services/documentation/documentation-auto-generate"
        );

        await autoGenerateDocumentationIfNeeded(systemId, regulations as any);
        success++;
      } catch (err) {
        failure++;
        console.error(`Doc regen failed for ${systemId}`, err);
      }
    }

    return res.json({
      systems: grouped.size,
      regenerated: success,
      failed: failure,
    });
  } catch (err: any) {
    console.error("Cron error:", err);
    return res.status(500).json({ error: err.message });
  }
}
